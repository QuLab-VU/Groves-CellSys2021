getCellLine <- function(x) gsub("^[cmS]\\.","",x)
getSource <- function(x) switch(substr(x,1,1),
c="CCLE",
m="Minna",
S="tumor",
NA)
phen <- data.frame(subtype=getSubtype(colnames(ccld)),
cell.line=getCellLine(colnames(ccld)),
source=sapply(colnames(ccld), getSource)
)
View(phen)
matdensity(as.matrix(ccld), groupFactor=substr(colnames(ccld),1,1))
mod <- model.matrix(~ cell.line, phen)
mod <- model.matrix(~ cell.line, phen)
mod0 <- model.matrix(~ 1, phen)
library(limma)
# data for correction; must remove genes containing any NA values
# Use CCLE/Minna data
dfc <- ccld[!apply(ccld,1,function(x) any(is.na(x))),]
# Choose method for determining the number of surrogate variables
n.sv <- num.sv(dfc, mod, method="leek")
# n.sv <- num.sv(dfc, mod, method="be")
# make a surrogate variable object
svobj <- sva(as.matrix(dfc), mod, mod0, n.sv=n.sv)
# plot it
plot(svobj$sv, pch=19)
mod <- model.matrix(~ cell.line, phen)
mod0 <- model.matrix(~ 1, phen)
library(limma)
# data for correction; must remove genes containing any NA values
# Use CCLE/Minna data
dfc <- ccld[!apply(ccld,1,function(x) any(is.na(x))),]
# Choose method for determining the number of surrogate variables
n.sv <- num.sv(dfc, mod, method="leek")
# make a surrogate variable object
svobj <- sva(as.matrix(dfc), mod, mod0, n.sv=n.sv)
# plot it
plot(svobj$sv, pch=19)
n.sv
mod
mod <- model.matrix(~ source, phen)
mod
n.sv <- num.sv(dfc, mod, method="leek")
n>sv
n.sv
mod0
svobj <- sva(as.matrix(dfc), mod, mod0)
# BiocManager::install("biomaRt")
# library(fst)
library(rtracklayer)            # needed for readGFF if reading in fst files
library(readxl)
library(quantro)
library(biomaRt)
# BiocManager::install("impute")
library(sva)
library(gplots)
library(quantro)
library(dendextend)
library(impute)
# BiocManager::install("biomaRt")
# library(fst)
library(rtracklayer)            # needed for readGFF if reading in fst files
library(readxl)
library(quantro)
library(biomaRt)
BiocManager::install("impute")
library(sva)
library(gplots)
library(quantro)
library(dendextend)
library(impute)
colbranches <- function(n, col)
{
# code modified from https://stackoverflow.com/questions/18036094/how-to-create-a-dendrogram-with-colored-branches
a <- attributes(n) # Find the attributes of current node
# Color edges with requested color
attr(n, "edgePar") <- c(a$edgePar, list(col=col, lwd=2))
n # Don't forget to return the node!
}
# extract information from dendrogram (e.g. colors for each node)
getLeafColors <- function(mydend) {
sd <- mydend
myleafs <- sd %>% get_nodes_attr("label")
myedgepar <- sd %>% get_nodes_attr("edgePar")
mycol <- sapply(myedgepar, "[[", 1)
names(mycol) <- myleafs
# remove NA values (should only have sample IDs and colors left)
mycol <- mycol[!is.na(mycol)]
mycol <- mycol[!is.na(names(mycol))]
return(mycol)
}
# BiocManager::install("biomaRt")
# library(fst)
library(rtracklayer)            # needed for readGFF if reading in fst files
library(readxl)
library(quantro)
library(biomaRt)
BiocManager::install("impute")
library(sva)
library(gplots)
library(quantro)
library(dendextend)
library(impute)
colbranches <- function(n, col)
{
# code modified from https://stackoverflow.com/questions/18036094/how-to-create-a-dendrogram-with-colored-branches
a <- attributes(n) # Find the attributes of current node
# Color edges with requested color
attr(n, "edgePar") <- c(a$edgePar, list(col=col, lwd=2))
n # Don't forget to return the node!
}
# extract information from dendrogram (e.g. colors for each node)
getLeafColors <- function(mydend) {
sd <- mydend
myleafs <- sd %>% get_nodes_attr("label")
myedgepar <- sd %>% get_nodes_attr("edgePar")
mycol <- sapply(myedgepar, "[[", 1)
names(mycol) <- myleafs
# remove NA values (should only have sample IDs and colors left)
mycol <- mycol[!is.na(mycol)]
mycol <- mycol[!is.na(names(mycol))]
return(mycol)
}
cm <- read.csv("../../data/bulk-rna-seq/SCLC_combined_Minna_CCLE_batch_corrected_wo_lowgenes.csv", as.is=TRUE,
row.names=1)
to <- read.csv(file.path('../../data/bulk-rna-seq/thomas_tumors.csv'),as.is=TRUE, row.names = 1)
t <- to
colnames(t) <- paste0('t.',colnames(t))
# different gene sets
allgenes <- sort(rownames(cm))
commongenes <- intersect(rownames(t),rownames(cm))
# combine all data keeping all genes
ad <- data.frame(gene=as.character(allgenes))
ad <- cbind(ad,cm[allgenes,])
ad <- cbind(ad,t[allgenes,])
rownames(ad) <- ad$gene
ad <- ad[,-1]
matdensity(as.matrix(ad[!apply(ad,1,function(x) any(is.na(x))),]), groupFactor=substr(colnames(ad),1,1))
matdensity(as.matrix(ad[!apply(ad,1,function(x) any(is.na(x))),]), groupFactor=substr(colnames(ad),1,1))
legend("topright", legend=sort(unique(substr(colnames(ad),1,1))), col=RColorBrewer::brewer.pal(8, "Dark2")[1:3], lwd=2)
# genes with missing data
genes_w_na <- rownames(ad)[apply(ad, 1, function(x) any(is.na(x)))]
lowgenes <- rownames(ad)[apply(ad, 1, function(x) all(x<log2(2)))]
# # save gene expression values of only variable genes in linear and log2 scale
# gev <- as.matrix(ad[vargenes,])
gev <- as.matrix(ad[!rownames(ad) %in% lowgenes,])
# genes common to all datasets
commongenes <- rownames(ad)[!apply(ad, 1, function(x) any(is.na(x)))]
DTU <- ad
anpy <- c("ASCL1","NEUROD1","POU2F3","YAP1")
# if any NEUROD1 data are NA, use NEUROD2 in place of NEUROD1 (e.g. GDSC data)
getSubtype <- function(ids,dat=DTU) {
nd1 <- dat["NEUROD1",]
nd2 <- sapply(seq_along(dat["NEUROD1",]), function(i)
ifelse(is.na(dat["NEUROD1",i]), dat["NEUROD2",i],dat["NEUROD1",i]))
if(anyNA(nd1)) dat["NEUROD1",] <- nd2
sapply(ids, function(x) {
out <- anpy[dat[anpy,x] == max(dat[anpy,x], na.rm=TRUE)]
out[!is.na(out)]
})
}
getCellLine <- function(x) gsub("^[cmt]\\.","",x)
getSource <- function(x) switch(substr(x,1,1),
c="CCLE",
m="Minna",
t="tumor",
NA)
phen <- data.frame(subtype=getSubtype(colnames(DTU)),
cell.line=getCellLine(colnames(DTU)),
source=sapply(colnames(DTU), getSource)
)
matdensity(as.matrix(DTU), groupFactor=substr(colnames(DTU),1,1))
mod <- model.matrix(~ cell.line, phen)
mod0 <- model.matrix(~ 1, phen)
library(limma)
# data for correction; must remove genes containing any NA values
# Use CCLE/Minna data
dfc <- DTU[!apply(DTU,1,function(x) any(is.na(x))),]
# Choose method for determining the number of surrogate variables
n.sv <- num.sv(dfc, mod, method="leek")
# n.sv <- num.sv(dfc, mod, method="be")
# make a surrogate variable object
svobj <- sva(as.matrix(dfc), mod, mod0, n.sv=n.sv)
# plot it
plot(svobj$sv, pch=19)
# if any NEUROD1 data are NA, use NEUROD2 in place of NEUROD1 (e.g. GDSC data)
getSubtype <- function(ids,dat=DTU) {
nd1 <- dat["NEUROD1",]
nd2 <- sapply(seq_along(dat["NEUROD1",]), function(i)
ifelse(is.na(dat["NEUROD1",i]), dat["NEUROD2",i],dat["NEUROD1",i]))
if(anyNA(nd1)) dat["NEUROD1",] <- nd2
sapply(ids, function(x) {
out <- anpy[dat[anpy,x] == max(dat[anpy,x], na.rm=TRUE)]
out[!is.na(out)]
})
}
getCellLine <- function(x) gsub("^[cmS]\\.","",x)
getSource <- function(x) switch(substr(x,1,1),
c="CCLE",
m="Minna",
S="tumor",
NA)
phen <- data.frame(subtype=getSubtype(colnames(DTU)),
cell.line=getCellLine(colnames(DTU)),
source=sapply(colnames(DTU), getSource)
)
matdensity(as.matrix(DTU), groupFactor=substr(colnames(DTU),1,1))
mod <- model.matrix(~ cell.line, phen)
mod0 <- model.matrix(~ 1, phen)
library(limma)
# data for correction; must remove genes containing any NA values
# Use CCLE/Minna data
dfc <- DTU[!apply(DTU,1,function(x) any(is.na(x))),]
# Choose method for determining the number of surrogate variables
n.sv <- num.sv(dfc, mod, method="leek")
# n.sv <- num.sv(dfc, mod, method="be")
n.sv
svobj <- sva(as.matrix(dfc), mod, mod0)
plot(svobj$sv, pch=19)
modSv = cbind(mod,svobj$sv)
mod0Sv = cbind(mod0,svobj$sv)
fit = lmFit(dfc,modSv)
# make a frozen surrogate variable object (i.e. batch-corrected)
fsvobj <- fsva(as.matrix(dfc), mod, svobj, newdat=as.matrix(dfc))
#
# batch-corrected data
bc <- fsvobj$new
plot(fsvobj$newsv, pch=19)
bc2 <- ComBat(as.matrix(dfc), batch=substr(colnames(dfc),1,1), mod = mod0,ref.batch = 'm')
bc2_mean.only <- ComBat(as.matrix(dfc), batch=substr(colnames(dfc),1,1), mod = mod0,mean.only = TRUE)
save(svobj, file="int/SCLC_SVA_obj.Rdata")
save(fsvobj, file="int/SCLC_Frozen_SVA_obj.Rdata")
save(svobj, file="./int/SCLC_SVA_obj.Rdata")
save(fsvobj, file="./int/SCLC_Frozen_SVA_obj.Rdata")
matdensity(bc, main="Batch corrected", xlab="log2 expression", ylab="density",
groupFactor=substr(colnames(bc2),1,1))
legend("topright",legend=c("CCLE","Minna","Tumor"), col=RColorBrewer::brewer.pal(8, "Dark2")[1:3], lwd=2)
matdensity(bc2, main="Batch corrected", xlab="log2 expression", ylab="density",
groupFactor=substr(colnames(bc2),1,1))
legend("topright",legend=c("CCLE","Minna","Tumor"), col=RColorBrewer::brewer.pal(8, "Dark2")[1:3], lwd=2)
matdensity(bc2_mean.only, main="Batch corrected", xlab="log2 expression", ylab="density",
groupFactor=substr(colnames(bc2),1,1))
legend("topright",legend=c("CCLE","Minna","Tumor"), col=RColorBrewer::brewer.pal(8, "Dark2")[1:3], lwd=2)
# BiocManager::install("biomaRt")
# library(fst)
library(rtracklayer)            # needed for readGFF if reading in fst files
library(readxl)
library(quantro)
library(biomaRt)
BiocManager::install("impute")
library(sva)
library(gplots)
library(quantro)
library(dendextend)
library(impute)
colbranches <- function(n, col)
{
# code modified from https://stackoverflow.com/questions/18036094/how-to-create-a-dendrogram-with-colored-branches
a <- attributes(n) # Find the attributes of current node
# Color edges with requested color
attr(n, "edgePar") <- c(a$edgePar, list(col=col, lwd=2))
n # Don't forget to return the node!
}
# extract information from dendrogram (e.g. colors for each node)
getLeafColors <- function(mydend) {
sd <- mydend
myleafs <- sd %>% get_nodes_attr("label")
myedgepar <- sd %>% get_nodes_attr("edgePar")
mycol <- sapply(myedgepar, "[[", 1)
names(mycol) <- myleafs
# remove NA values (should only have sample IDs and colors left)
mycol <- mycol[!is.na(mycol)]
mycol <- mycol[!is.na(names(mycol))]
return(mycol)
}
cm <- read.csv("../../data/bulk-rna-seq/SCLC_combined_Minna_CCLE_batch_corrected_wo_lowgenes.csv", as.is=TRUE,
row.names=1)
to <- read.csv(file.path('../../data/bulk-rna-seq/thomas_tumors.csv'),as.is=TRUE, row.names = 1)
t <- to
colnames(t) <- paste0('t.',colnames(t))
# different gene sets
allgenes <- sort(rownames(cm))
commongenes <- intersect(rownames(t),rownames(cm))
# combine all data keeping all genes
ad <- data.frame(gene=as.character(allgenes))
ad <- cbind(ad,cm[allgenes,])
ad <- cbind(ad,t[allgenes,])
rownames(ad) <- ad$gene
ad <- ad[,-1]
matdensity(as.matrix(ad[!apply(ad,1,function(x) any(is.na(x))),]), groupFactor=substr(colnames(ad),1,1))
legend("topright", legend=sort(unique(substr(colnames(ad),1,1))), col=RColorBrewer::brewer.pal(8, "Dark2")[1:3], lwd=2)
# genes with missing data
genes_w_na <- rownames(ad)[apply(ad, 1, function(x) any(is.na(x)))]
# essential genes (genes that are missing from microarray data but need to be included for biological interpretation)
# missing_immune_genes <- c("NCR3LG1","MICA","ENTPD1","CD24")
lowgenes <- rownames(ad)[apply(ad, 1, function(x) all(x<log2(2)))]
# # save gene expression values of only variable genes in linear and log2 scale
# gev <- as.matrix(ad[vargenes,])
gev <- as.matrix(ad[!rownames(ad) %in% lowgenes,])
# # show which data sources have NA values for each essential gene
# message("Source with NA in specific genes")
# sapply(essential_missing_genes, function(x) sapply(c("c","m","t"), function(z)
#     anyNA(as.matrix(ad[x,substr(colnames(ad),1,1)==z]))))
# genes common to all datasets
commongenes <- rownames(ad)[!apply(ad, 1, function(x) any(is.na(x)))]
matdensity(as.matrix(DTU), groupFactor=substr(colnames(DTU),1,1))
matdensity(bc, main="Batch corrected", xlab="log2 expression", ylab="density",
groupFactor=substr(colnames(bc2),1,1))
legend("topright",legend=c("CCLE","Minna","Tumor"), col=RColorBrewer::brewer.pal(8, "Dark2")[1:3], lwd=2)
matdensity(bc2, main="Batch corrected", xlab="log2 expression", ylab="density",
groupFactor=substr(colnames(bc2),1,1))
legend("topright",legend=c("CCLE","Minna","Tumor"), col=RColorBrewer::brewer.pal(8, "Dark2")[1:3], lwd=2)
matdensity(bc2_mean.only, main="Batch corrected", xlab="log2 expression", ylab="density",
groupFactor=substr(colnames(bc2),1,1))
legend("topright",legend=c("CCLE","Minna","Tumor"), col=RColorBrewer::brewer.pal(8, "Dark2")[1:3], lwd=2)
write.csv(bc2, file = "../../data/bulk-rna-seq/CCLE_Minna_Thomas_COMBAT.csv")
View(bc2)
knitr::opts_chunk$set(echo = TRUE)
# BiocManager::install(c('fdrtool','ade4','rgl'))
library(fdrtool)
library(ade4)
# library(rgl)
library(ggrepel)
library(stringr)
# BiocManager::install('tidyverse')
library(tidyverse)
library(forcats)
## Import archetype color scheme
# source("../ParTI-code/hallmarkOmeter.inc.R")
##################################################
## Make matrix of tissue archetypes vs super-archetypes
# Read in significant enrichment for "Super Archetypes" (CMT data)
SAMSig <- read.csv("../ParTI-code/combined-data/out/5/100473_continuous_significant.csv")
SAMSig <- SAMSig %>% dplyr::filter(Mean.Difference > 0.1)
# # This makes a list of all of the archetypes (# and p value) for each dataset, and makes a list of files, one enrichment file per dataset. This is unnecessary for us to do
# cancerIDs <-
#     read_tsv("../TCGA_frac_nArchs.tab", col_names=F) %>% .[,1] %>%
#     unlist %>% as.character %>%
#     setdiff(c("HNSC", "LUAD", "BRCA"))
# arcsMSigFiles <-
#     c(paste("../", cancerIDs,
#             "_UCSC/MSigDBenrichment_continuous_significant.csv",
#             sep=""),
#       "~/work/cancerTaskAtlas/brca_metabric/MSigDBenrichment_continuous_significant.csv")
# cancerIDs <- c(cancerIDs, "BRCA")
# cbind(cancerIDs, arcsMSigFiles)
arcsMSig <-read.csv('../ParTI-code/human-cell-lines/out/5/322234/322234_continuous_significant.csv') %>%
dplyr::filter(Mean.Difference > 0.1)
featsUniv <- dplyr::union(SAMSig %>% dplyr::select("Feature.Name"),
arcsMSig %>% dplyr::select("Feature.Name"))
arcIdx <- 1;
SAmapping <- # iterate over tissue archetypes
map(unlist(arcsMSig %>% dplyr::select(archetype..) %>% unique), function(arcIdx) {
SAidx <- 1;
arcScores <- # iterate over super-archetypes
map(unlist(SAMSig %>% dplyr::select(archetype..) %>% unique),
function(SAidx) {
SAfeats <- SAMSig %>%
dplyr::filter(archetype.. == SAidx) %>%
dplyr::select(Feature.Name)
arcFeats <- arcsMSig %>%
dplyr::filter(archetype.. == arcIdx) %>%
dplyr::select(Feature.Name)
## nrow(SAfeats)
## nrow(arcFeats)
expIntersect <- nrow(SAfeats) * nrow(arcFeats) / nrow(featsUniv)
## phyper(q, m, n, k, lower.tail = TRUE, log.p = FALSE)
## q,x: number of white balls drawn without
## replacement from an urn which contains
## both black and white balls.
## m: the number of white balls in the urn.
## n: the number of black balls in the urn.
## k: the number of balls drawn from the urn.
p <- phyper(q=intersect(SAfeats, arcFeats) %>% nrow,
m=SAfeats %>% nrow,
n=nrow(featsUniv) - nrow(SAfeats),
k=arcFeats %>% nrow,
lower.tail=F)
foldEnrich <- nrow(intersect(SAfeats, arcFeats)) / expIntersect;
## Bonferroni
cutOff <- .01 /
((arcsMSig %>% dplyr::select(archetype..) %>%
unique %>% nrow) *
(SAMSig %>% dplyr::select(archetype..) %>%
unique %>% nrow))
return(c("obs"=nrow(intersect(SAfeats, arcFeats)),
"exp"=expIntersect,
"p"=p,
"isSignif"=p<cutOff))
})
arcScoresT <-
sapply(arcScores, function(x) { x }) %>% t %>% as.data.frame %>%
rownames_to_column() %>%
mutate(tissueArch=arcIdx) %>%
rename("univArch"=rowname)
return(arcScoresT)
})
# save.image("~/Documents/Github/Groves-CellSys2021/notebooks/ParTI-code/SAmapping.RData")
# load("/Users/smgroves/Documents/Github/Groves-CellSys2021/notebooks/ParTI-code/SAmapping.RData")
View(SAmapping)
# Tumor vs Cell Line
SAMSig <-read.csv('../ParTI-code/thomas-tumors/out/5/') %>%
dplyr::filter(Mean.Difference > 0.1)
# Tumor vs Cell Line
SAMSig <-read.csv('../ParTI-code/thomas-tumors/out/5/538361_continuous_significant') %>%
dplyr::filter(Mean.Difference > 0.1)
# Tumor vs Cell Line
SAMSig <-read.csv('../ParTI-code/thomas-tumors/out/5/538361_continuous_significant.csv') %>%
dplyr::filter(Mean.Difference > 0.1)
featsUniv <- dplyr::union(SAMSig %>% dplyr::select("Feature.Name"),
arcsMSig %>% dplyr::select("Feature.Name"))
arcIdx <- 1;
SAmappingTumor <- # iterate over tissue archetypes
map(unlist(arcsMSig %>% dplyr::select(archetype..) %>% unique), function(arcIdx) {
SAidx <- 1;
arcScores <- # iterate over super-archetypes
map(unlist(SAMSig %>% dplyr::select(archetype..) %>% unique),
function(SAidx) {
SAfeats <- SAMSig %>%
dplyr::filter(archetype.. == SAidx) %>%
dplyr::select(Feature.Name)
arcFeats <- arcsMSig %>%
dplyr::filter(archetype.. == arcIdx) %>%
dplyr::select(Feature.Name)
## nrow(SAfeats)
## nrow(arcFeats)
expIntersect <- nrow(SAfeats) * nrow(arcFeats) / nrow(featsUniv)
## phyper(q, m, n, k, lower.tail = TRUE, log.p = FALSE)
## q,x: number of white balls drawn without
## replacement from an urn which contains
## both black and white balls.
## m: the number of white balls in the urn.
## n: the number of black balls in the urn.
## k: the number of balls drawn from the urn.
p <- phyper(q=intersect(SAfeats, arcFeats) %>% nrow,
m=SAfeats %>% nrow,
n=nrow(featsUniv) - nrow(SAfeats),
k=arcFeats %>% nrow,
lower.tail=F)
foldEnrich <- nrow(intersect(SAfeats, arcFeats)) / expIntersect;
## Bonferroni
cutOff <- .01 /
((arcsMSig %>% dplyr::select(archetype..) %>%
unique %>% nrow) *
(SAMSig %>% dplyr::select(archetype..) %>%
unique %>% nrow))
return(c("obs"=nrow(intersect(SAfeats, arcFeats)),
"exp"=expIntersect,
"p"=p,
"isSignif"=p<cutOff))
})
arcScoresT <-
sapply(arcScores, function(x) { x }) %>% t %>% as.data.frame %>%
rownames_to_column() %>%
mutate(tissueArch=arcIdx) %>%
rename("univArch"=rowname)
return(arcScoresT)
})
View(SAmappingTumor)
# Tumor vs Cell Line
SAMSig <-read.csv('../ParTI-code/thomas-tumors/out/5/927196_continuous_significant.csv') %>%
dplyr::filter(Mean.Difference > 0.1)
featsUniv <- dplyr::union(SAMSig %>% dplyr::select("Feature.Name"),
arcsMSig %>% dplyr::select("Feature.Name"))
arcIdx <- 1;
SAmappingTumor <- # iterate over tissue archetypes
map(unlist(arcsMSig %>% dplyr::select(archetype..) %>% unique), function(arcIdx) {
SAidx <- 1;
arcScores <- # iterate over super-archetypes
map(unlist(SAMSig %>% dplyr::select(archetype..) %>% unique),
function(SAidx) {
SAfeats <- SAMSig %>%
dplyr::filter(archetype.. == SAidx) %>%
dplyr::select(Feature.Name)
arcFeats <- arcsMSig %>%
dplyr::filter(archetype.. == arcIdx) %>%
dplyr::select(Feature.Name)
## nrow(SAfeats)
## nrow(arcFeats)
expIntersect <- nrow(SAfeats) * nrow(arcFeats) / nrow(featsUniv)
## phyper(q, m, n, k, lower.tail = TRUE, log.p = FALSE)
## q,x: number of white balls drawn without
## replacement from an urn which contains
## both black and white balls.
## m: the number of white balls in the urn.
## n: the number of black balls in the urn.
## k: the number of balls drawn from the urn.
p <- phyper(q=intersect(SAfeats, arcFeats) %>% nrow,
m=SAfeats %>% nrow,
n=nrow(featsUniv) - nrow(SAfeats),
k=arcFeats %>% nrow,
lower.tail=F)
foldEnrich <- nrow(intersect(SAfeats, arcFeats)) / expIntersect;
## Bonferroni
cutOff <- .01 /
((arcsMSig %>% dplyr::select(archetype..) %>%
unique %>% nrow) *
(SAMSig %>% dplyr::select(archetype..) %>%
unique %>% nrow))
return(c("obs"=nrow(intersect(SAfeats, arcFeats)),
"exp"=expIntersect,
"p"=p,
"isSignif"=p<cutOff))
})
arcScoresT <-
sapply(arcScores, function(x) { x }) %>% t %>% as.data.frame %>%
rownames_to_column() %>%
mutate(tissueArch=arcIdx) %>%
rename("univArch"=rowname)
return(arcScoresT)
})
View(SAmappingTumor)

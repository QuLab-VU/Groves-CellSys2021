# z[z==0] <- min(z[z!=0])
# z <- log2(z)
# z[z < -2] <- 0
return(z+1)
}
cleanMinnaData <- function(z)
{
# remove first column (GENE_ID)
z <- z[,-1]
# move gene names (COMMON) to rownames and remove column
rownames(z) <- z[,1]
z <- z[,-1]
# remove cell lines with all NAs
z <- z[,!apply(z,2,function(x) all(is.na(x)))]
# remove gene with all NAs
z <- z[!apply(z,1,function(x) all(is.na(x))),]
# remove mitochondrial genes
z <- z[!grepl('^MT-',rownames(z)),]
# remove periods from cell line names (colnames)
colnames(z) <- gsub('.','',colnames(z),fixed=TRUE)
# Add "NCI" in front of H-designation cell lines to match other datasets
colnames(z)[grepl('^H[1-9]',colnames(z))] <-
paste0('NCI',colnames(z)[grepl('^H[1-9]',colnames(z))])
# NOTE: rounding will cause some data loss
return(round(2^z,4))
}
cleanGDSCdata <- function(z,
clinfopath='../data/GDSC_Cell_Lines_Details.xlsx',
geneinfopath="../data/ENSEMBL-GENE_ID_Table.txt",
clsubset='SCLC')
{
# NOTE: colnames are COSMIC IDs for cell lines
# must match using annotation file from GDSC
clinfo <- read_xlsx(clinfopath)
cn <- colnames(clinfo)
cn <- gsub('\r\n', ' ', cn, fixed=TRUE)
cn <- gsub('  ', ' ', cn)
colnames(clinfo) <- cn
clinfo <- as.data.frame(clinfo)
clinfo$cell.line <- gsub('-','',toupper(clinfo$"Sample Name"))
# leave "NCI" prefix on Minna cell lines for consistency with other data
# clinfo$cell.line <- gsub('^NCI','',clinfo$cell.line)
lungcl <- clinfo[
grep('[lL]ung',clinfo[,'GDSC Tissue descriptor 2']),
'cell.line']
sclccl <- clinfo[grep('small',clinfo[,'GDSC Tissue descriptor 2']),
'cell.line']
# move gene names to rownames and remove column
rownames(z) <- z[,1]
z <- z[,-1]
# remove cell lines with all NAs
z <- z[,!apply(z,2,function(x) all(is.na(x)))]
# remove gene with all NAs
z <- z[!apply(z,1,function(x) all(is.na(x))),]
# remove mitochondrial genes
z <- z[!grepl('^MT-',rownames(z)),]
geneinfo <- read.csv(geneinfopath,sep='\t')
gn <- sapply(rownames(z), function(x)
geneinfo[match(x,geneinfo$Ensembl.gene.ID),'Approved.symbol'])
# remove genes without gene name
z <- z[!is.na(gn),]
rownames(z) <- gn[!is.na(gn)]
clname <- sapply(colnames(z), function(x)
clinfo[match(gsub('^X','',x),clinfo$'COSMIC identifier'),'cell.line'])
colnames(z) <- clname
# return subset of data based on value of clsubset; default is "SCLC"
if(clsubset == 'SCLC')
{
return(z[,colnames(z) %in% sclccl])
} else if (clsubset == 'lung'){
return(z[,colnames(z) %in% lungcl])
} else {
return(z)
}
}
pwd
wd
getwd()
getwd()
setwd("~/Documents/Github/Groves-CellSys2021/notebooks/bulk")
# First load batch-corrected RNA-seq data
l2gev_bc <- read.csv("../../data/SCLC_combined_Minna_CCLE_batch_corrected_wo_lowgenes.csv",
as.is=TRUE, row.names=1)
# First load batch-corrected RNA-seq data
l2gev_bc <- read.csv("../../data/bulk-rna-seq/SCLC_combined_Minna_CCLE_batch_corrected_wo_lowgenes.csv",
as.is=TRUE, row.names=1)
# load GDSC data from file containing all SCLC datasets
g <- read.csv('../../data/bulk-rna-seq/thomas_tumors.csv', as.is=TRUE, row.names=1)
View(g)
# load GDSC data from file containing all SCLC datasets
g <- read.csv('../../data/bulk-rna-seq/thomas_tumors.csv', as.is=TRUE, row.names=1,header = FALSE)
View(g)
# load GDSC data from file containing all SCLC datasets
g <- read.csv('../../data/bulk-rna-seq/thomas_tumors.csv', as.is=TRUE, row.names=1,header = TRUE)
View(g)
View(l2gev_bc)
ccld <- as.matrix(cbind(l2gev_bc,g[rownames(l2gev_bc),]))
View(ccld)
# if (!requireNamespace("BiocManager", quietly = TRUE))
#     install.packages("BiocManager")
#
# BiocManager::install("preprocessCore")
BiocManager::install("quantro")
# BiocManager::install("MineICA")
# BiocManager::install("KEGG.db")
# BiocManager::install("RUVSeq")
# BiocManager::install("BatchQC")
# BiocManager::install("sva")
# These packages are needed if accessing raw data files on vu1file
# library(RUVSeq)
# library(fst)                    # needed for read.fst
# library(rtracklayer)            # needed for readGFF if reading in fst files
# source('fsqn.R')
# library(preprocessCore)         # has normalize.quantiles function
# library(BatchQC)
# These packages are required for all processing
library(quantro)
library(sva)
matdensity(as.matrix(ccld),
groupFactor=substr(colnames(ccld),1,1), xlab="log2(expression)",
ylab="density")
```{r}
matdensity(as.matrix(ccld),
groupFactor=substr(colnames(ccld),1,1), xlab="log2(expression)",
ylab="density")
matdensity(as.matrix(ccld),
groupFactor=substr(colnames(ccld),1,1), xlab="log2(expression)",
ylab="density")
legend("topright", legend=c("Minna", "Tumors", "CCLE"),
col=RColorBrewer::brewer.pal(8, "Dark2")[1:3], lwd=3)
hist(as.matrix(z[,grep("^S",colnames(z))]))
hist(as.matrix(ccld[,grep("^S",colnames(ccld))]))
help(substr)
# condition <- subtype_info[match(colnames(ccld),rownames(subtype_info)),'phenotype']
batchQC(dat=ccld, batch=substr(colnames(ccld),1,1),# condition=condition,
report_file="batchqc_report.html", report_dir=save_dir,
report_option_binary="111111111",
view_report=TRUE, interactive=TRUE, batchqc_output=TRUE)
# BiocManager::install("MineICA")
# BiocManager::install("KEGG.db")
# BiocManager::install("RUVSeq")
BiocManager::install("BatchQC")
rstudioapi::showDialog("Target directory", "Please choose a directory where any exported graphs will be saved.")
save_dir <- file.path(paste0(chooseDir(),'/'))
# condition <- subtype_info[match(colnames(ccld),rownames(subtype_info)),'phenotype']
batchQC(dat=ccld, batch=substr(colnames(ccld),1,1),# condition=condition,
report_file="batchqc_report.html", report_dir=save_dir,
report_option_binary="111111111",
view_report=TRUE, interactive=TRUE, batchqc_output=TRUE)
# BiocManager::install("sva")
# These packages are needed if accessing raw data files on vu1file
# library(RUVSeq)
# library(fst)                    # needed for read.fst
# library(rtracklayer)            # needed for readGFF if reading in fst files
# source('fsqn.R')
# library(preprocessCore)         # has normalize.quantiles function
library(BatchQC)
batchQC(dat=ccld, batch=substr(colnames(ccld),1,1),# condition=condition,
report_file="batchqc_report.html", report_dir=save_dir,
report_option_binary="111111111",
view_report=TRUE, interactive=TRUE, batchqc_output=TRUE)
anpy <- c("ASCL1","NEUROD1","POU2F3","YAP1")
# if any NEUROD1 data are NA, use NEUROD2 in place of NEUROD1 (e.g. GDSC data)
getSubtype <- function(ids,dat=ccld) {
nd1 <- dat["NEUROD1",]
nd2 <- sapply(seq_along(dat["NEUROD1",]), function(i)
ifelse(is.na(dat["NEUROD1",i]), dat["NEUROD2",i],dat["NEUROD1",i]))
if(anyNA(nd1)) dat["NEUROD1",] <- nd2
sapply(ids, function(x) {
out <- anpy[dat[anpy,x] == max(dat[anpy,x], na.rm=TRUE)]
out[!is.na(out)]
})
}
getCellLine <- function(x) gsub("^[cmt]\\.","",x)
getSource <- function(x) switch(substr(x,1,1),
c="CCLE",
m="Minna",
t="tumor",
NA)
phen <- data.frame(subtype=getSubtype(colnames(ccld)),
cell.line=getCellLine(colnames(ccld)),
source=sapply(colnames(ccld), getSource)
)
View(phen)
# if any NEUROD1 data are NA, use NEUROD2 in place of NEUROD1 (e.g. GDSC data)
getSubtype <- function(ids,dat=ccld) {
nd1 <- dat["NEUROD1",]
nd2 <- sapply(seq_along(dat["NEUROD1",]), function(i)
ifelse(is.na(dat["NEUROD1",i]), dat["NEUROD2",i],dat["NEUROD1",i]))
if(anyNA(nd1)) dat["NEUROD1",] <- nd2
sapply(ids, function(x) {
out <- anpy[dat[anpy,x] == max(dat[anpy,x], na.rm=TRUE)]
out[!is.na(out)]
})
}
getCellLine <- function(x) gsub("^[cmS]\\.","",x)
getSource <- function(x) switch(substr(x,1,1),
c="CCLE",
m="Minna",
S="tumor",
NA)
phen <- data.frame(subtype=getSubtype(colnames(ccld)),
cell.line=getCellLine(colnames(ccld)),
source=sapply(colnames(ccld), getSource)
)
View(phen)
matdensity(as.matrix(ccld), groupFactor=substr(colnames(ccld),1,1))
mod <- model.matrix(~ cell.line, phen)
mod <- model.matrix(~ cell.line, phen)
mod0 <- model.matrix(~ 1, phen)
library(limma)
# data for correction; must remove genes containing any NA values
# Use CCLE/Minna data
dfc <- ccld[!apply(ccld,1,function(x) any(is.na(x))),]
# Choose method for determining the number of surrogate variables
n.sv <- num.sv(dfc, mod, method="leek")
# n.sv <- num.sv(dfc, mod, method="be")
# make a surrogate variable object
svobj <- sva(as.matrix(dfc), mod, mod0, n.sv=n.sv)
# plot it
plot(svobj$sv, pch=19)
mod <- model.matrix(~ cell.line, phen)
mod0 <- model.matrix(~ 1, phen)
library(limma)
# data for correction; must remove genes containing any NA values
# Use CCLE/Minna data
dfc <- ccld[!apply(ccld,1,function(x) any(is.na(x))),]
# Choose method for determining the number of surrogate variables
n.sv <- num.sv(dfc, mod, method="leek")
# make a surrogate variable object
svobj <- sva(as.matrix(dfc), mod, mod0, n.sv=n.sv)
# plot it
plot(svobj$sv, pch=19)
n.sv
mod
mod <- model.matrix(~ source, phen)
mod
n.sv <- num.sv(dfc, mod, method="leek")
n>sv
n.sv
mod0
svobj <- sva(as.matrix(dfc), mod, mod0)
# BiocManager::install("biomaRt")
# library(fst)
library(rtracklayer)            # needed for readGFF if reading in fst files
library(readxl)
library(quantro)
library(biomaRt)
# BiocManager::install("impute")
library(sva)
library(gplots)
library(quantro)
library(dendextend)
library(impute)
# BiocManager::install("biomaRt")
# library(fst)
library(rtracklayer)            # needed for readGFF if reading in fst files
library(readxl)
library(quantro)
library(biomaRt)
BiocManager::install("impute")
library(sva)
library(gplots)
library(quantro)
library(dendextend)
library(impute)
colbranches <- function(n, col)
{
# code modified from https://stackoverflow.com/questions/18036094/how-to-create-a-dendrogram-with-colored-branches
a <- attributes(n) # Find the attributes of current node
# Color edges with requested color
attr(n, "edgePar") <- c(a$edgePar, list(col=col, lwd=2))
n # Don't forget to return the node!
}
# extract information from dendrogram (e.g. colors for each node)
getLeafColors <- function(mydend) {
sd <- mydend
myleafs <- sd %>% get_nodes_attr("label")
myedgepar <- sd %>% get_nodes_attr("edgePar")
mycol <- sapply(myedgepar, "[[", 1)
names(mycol) <- myleafs
# remove NA values (should only have sample IDs and colors left)
mycol <- mycol[!is.na(mycol)]
mycol <- mycol[!is.na(names(mycol))]
return(mycol)
}
# BiocManager::install("biomaRt")
# library(fst)
library(rtracklayer)            # needed for readGFF if reading in fst files
library(readxl)
library(quantro)
library(biomaRt)
BiocManager::install("impute")
library(sva)
library(gplots)
library(quantro)
library(dendextend)
library(impute)
colbranches <- function(n, col)
{
# code modified from https://stackoverflow.com/questions/18036094/how-to-create-a-dendrogram-with-colored-branches
a <- attributes(n) # Find the attributes of current node
# Color edges with requested color
attr(n, "edgePar") <- c(a$edgePar, list(col=col, lwd=2))
n # Don't forget to return the node!
}
# extract information from dendrogram (e.g. colors for each node)
getLeafColors <- function(mydend) {
sd <- mydend
myleafs <- sd %>% get_nodes_attr("label")
myedgepar <- sd %>% get_nodes_attr("edgePar")
mycol <- sapply(myedgepar, "[[", 1)
names(mycol) <- myleafs
# remove NA values (should only have sample IDs and colors left)
mycol <- mycol[!is.na(mycol)]
mycol <- mycol[!is.na(names(mycol))]
return(mycol)
}
cm <- read.csv("../../data/bulk-rna-seq/SCLC_combined_Minna_CCLE_batch_corrected_wo_lowgenes.csv", as.is=TRUE,
row.names=1)
to <- read.csv(file.path('../../data/bulk-rna-seq/thomas_tumors.csv'),as.is=TRUE, row.names = 1)
t <- to
colnames(t) <- paste0('t.',colnames(t))
# different gene sets
allgenes <- sort(rownames(cm))
commongenes <- intersect(rownames(t),rownames(cm))
# combine all data keeping all genes
ad <- data.frame(gene=as.character(allgenes))
ad <- cbind(ad,cm[allgenes,])
ad <- cbind(ad,t[allgenes,])
rownames(ad) <- ad$gene
ad <- ad[,-1]
matdensity(as.matrix(ad[!apply(ad,1,function(x) any(is.na(x))),]), groupFactor=substr(colnames(ad),1,1))
matdensity(as.matrix(ad[!apply(ad,1,function(x) any(is.na(x))),]), groupFactor=substr(colnames(ad),1,1))
legend("topright", legend=sort(unique(substr(colnames(ad),1,1))), col=RColorBrewer::brewer.pal(8, "Dark2")[1:3], lwd=2)
# genes with missing data
genes_w_na <- rownames(ad)[apply(ad, 1, function(x) any(is.na(x)))]
lowgenes <- rownames(ad)[apply(ad, 1, function(x) all(x<log2(2)))]
# # save gene expression values of only variable genes in linear and log2 scale
# gev <- as.matrix(ad[vargenes,])
gev <- as.matrix(ad[!rownames(ad) %in% lowgenes,])
# genes common to all datasets
commongenes <- rownames(ad)[!apply(ad, 1, function(x) any(is.na(x)))]
DTU <- ad
anpy <- c("ASCL1","NEUROD1","POU2F3","YAP1")
# if any NEUROD1 data are NA, use NEUROD2 in place of NEUROD1 (e.g. GDSC data)
getSubtype <- function(ids,dat=DTU) {
nd1 <- dat["NEUROD1",]
nd2 <- sapply(seq_along(dat["NEUROD1",]), function(i)
ifelse(is.na(dat["NEUROD1",i]), dat["NEUROD2",i],dat["NEUROD1",i]))
if(anyNA(nd1)) dat["NEUROD1",] <- nd2
sapply(ids, function(x) {
out <- anpy[dat[anpy,x] == max(dat[anpy,x], na.rm=TRUE)]
out[!is.na(out)]
})
}
getCellLine <- function(x) gsub("^[cmt]\\.","",x)
getSource <- function(x) switch(substr(x,1,1),
c="CCLE",
m="Minna",
t="tumor",
NA)
phen <- data.frame(subtype=getSubtype(colnames(DTU)),
cell.line=getCellLine(colnames(DTU)),
source=sapply(colnames(DTU), getSource)
)
matdensity(as.matrix(DTU), groupFactor=substr(colnames(DTU),1,1))
mod <- model.matrix(~ cell.line, phen)
mod0 <- model.matrix(~ 1, phen)
library(limma)
# data for correction; must remove genes containing any NA values
# Use CCLE/Minna data
dfc <- DTU[!apply(DTU,1,function(x) any(is.na(x))),]
# Choose method for determining the number of surrogate variables
n.sv <- num.sv(dfc, mod, method="leek")
# n.sv <- num.sv(dfc, mod, method="be")
# make a surrogate variable object
svobj <- sva(as.matrix(dfc), mod, mod0, n.sv=n.sv)
# plot it
plot(svobj$sv, pch=19)
# if any NEUROD1 data are NA, use NEUROD2 in place of NEUROD1 (e.g. GDSC data)
getSubtype <- function(ids,dat=DTU) {
nd1 <- dat["NEUROD1",]
nd2 <- sapply(seq_along(dat["NEUROD1",]), function(i)
ifelse(is.na(dat["NEUROD1",i]), dat["NEUROD2",i],dat["NEUROD1",i]))
if(anyNA(nd1)) dat["NEUROD1",] <- nd2
sapply(ids, function(x) {
out <- anpy[dat[anpy,x] == max(dat[anpy,x], na.rm=TRUE)]
out[!is.na(out)]
})
}
getCellLine <- function(x) gsub("^[cmS]\\.","",x)
getSource <- function(x) switch(substr(x,1,1),
c="CCLE",
m="Minna",
S="tumor",
NA)
phen <- data.frame(subtype=getSubtype(colnames(DTU)),
cell.line=getCellLine(colnames(DTU)),
source=sapply(colnames(DTU), getSource)
)
matdensity(as.matrix(DTU), groupFactor=substr(colnames(DTU),1,1))
mod <- model.matrix(~ cell.line, phen)
mod0 <- model.matrix(~ 1, phen)
library(limma)
# data for correction; must remove genes containing any NA values
# Use CCLE/Minna data
dfc <- DTU[!apply(DTU,1,function(x) any(is.na(x))),]
# Choose method for determining the number of surrogate variables
n.sv <- num.sv(dfc, mod, method="leek")
# n.sv <- num.sv(dfc, mod, method="be")
n.sv
svobj <- sva(as.matrix(dfc), mod, mod0)
plot(svobj$sv, pch=19)
modSv = cbind(mod,svobj$sv)
mod0Sv = cbind(mod0,svobj$sv)
fit = lmFit(dfc,modSv)
# make a frozen surrogate variable object (i.e. batch-corrected)
fsvobj <- fsva(as.matrix(dfc), mod, svobj, newdat=as.matrix(dfc))
#
# batch-corrected data
bc <- fsvobj$new
plot(fsvobj$newsv, pch=19)
bc2 <- ComBat(as.matrix(dfc), batch=substr(colnames(dfc),1,1), mod = mod0,ref.batch = 'm')
bc2_mean.only <- ComBat(as.matrix(dfc), batch=substr(colnames(dfc),1,1), mod = mod0,mean.only = TRUE)
save(svobj, file="int/SCLC_SVA_obj.Rdata")
save(fsvobj, file="int/SCLC_Frozen_SVA_obj.Rdata")
save(svobj, file="./int/SCLC_SVA_obj.Rdata")
save(fsvobj, file="./int/SCLC_Frozen_SVA_obj.Rdata")
matdensity(bc, main="Batch corrected", xlab="log2 expression", ylab="density",
groupFactor=substr(colnames(bc2),1,1))
legend("topright",legend=c("CCLE","Minna","Tumor"), col=RColorBrewer::brewer.pal(8, "Dark2")[1:3], lwd=2)
matdensity(bc2, main="Batch corrected", xlab="log2 expression", ylab="density",
groupFactor=substr(colnames(bc2),1,1))
legend("topright",legend=c("CCLE","Minna","Tumor"), col=RColorBrewer::brewer.pal(8, "Dark2")[1:3], lwd=2)
matdensity(bc2_mean.only, main="Batch corrected", xlab="log2 expression", ylab="density",
groupFactor=substr(colnames(bc2),1,1))
legend("topright",legend=c("CCLE","Minna","Tumor"), col=RColorBrewer::brewer.pal(8, "Dark2")[1:3], lwd=2)
# BiocManager::install("biomaRt")
# library(fst)
library(rtracklayer)            # needed for readGFF if reading in fst files
library(readxl)
library(quantro)
library(biomaRt)
BiocManager::install("impute")
library(sva)
library(gplots)
library(quantro)
library(dendextend)
library(impute)
colbranches <- function(n, col)
{
# code modified from https://stackoverflow.com/questions/18036094/how-to-create-a-dendrogram-with-colored-branches
a <- attributes(n) # Find the attributes of current node
# Color edges with requested color
attr(n, "edgePar") <- c(a$edgePar, list(col=col, lwd=2))
n # Don't forget to return the node!
}
# extract information from dendrogram (e.g. colors for each node)
getLeafColors <- function(mydend) {
sd <- mydend
myleafs <- sd %>% get_nodes_attr("label")
myedgepar <- sd %>% get_nodes_attr("edgePar")
mycol <- sapply(myedgepar, "[[", 1)
names(mycol) <- myleafs
# remove NA values (should only have sample IDs and colors left)
mycol <- mycol[!is.na(mycol)]
mycol <- mycol[!is.na(names(mycol))]
return(mycol)
}
cm <- read.csv("../../data/bulk-rna-seq/SCLC_combined_Minna_CCLE_batch_corrected_wo_lowgenes.csv", as.is=TRUE,
row.names=1)
to <- read.csv(file.path('../../data/bulk-rna-seq/thomas_tumors.csv'),as.is=TRUE, row.names = 1)
t <- to
colnames(t) <- paste0('t.',colnames(t))
# different gene sets
allgenes <- sort(rownames(cm))
commongenes <- intersect(rownames(t),rownames(cm))
# combine all data keeping all genes
ad <- data.frame(gene=as.character(allgenes))
ad <- cbind(ad,cm[allgenes,])
ad <- cbind(ad,t[allgenes,])
rownames(ad) <- ad$gene
ad <- ad[,-1]
matdensity(as.matrix(ad[!apply(ad,1,function(x) any(is.na(x))),]), groupFactor=substr(colnames(ad),1,1))
legend("topright", legend=sort(unique(substr(colnames(ad),1,1))), col=RColorBrewer::brewer.pal(8, "Dark2")[1:3], lwd=2)
# genes with missing data
genes_w_na <- rownames(ad)[apply(ad, 1, function(x) any(is.na(x)))]
# essential genes (genes that are missing from microarray data but need to be included for biological interpretation)
# missing_immune_genes <- c("NCR3LG1","MICA","ENTPD1","CD24")
lowgenes <- rownames(ad)[apply(ad, 1, function(x) all(x<log2(2)))]
# # save gene expression values of only variable genes in linear and log2 scale
# gev <- as.matrix(ad[vargenes,])
gev <- as.matrix(ad[!rownames(ad) %in% lowgenes,])
# # show which data sources have NA values for each essential gene
# message("Source with NA in specific genes")
# sapply(essential_missing_genes, function(x) sapply(c("c","m","t"), function(z)
#     anyNA(as.matrix(ad[x,substr(colnames(ad),1,1)==z]))))
# genes common to all datasets
commongenes <- rownames(ad)[!apply(ad, 1, function(x) any(is.na(x)))]
matdensity(as.matrix(DTU), groupFactor=substr(colnames(DTU),1,1))
matdensity(bc, main="Batch corrected", xlab="log2 expression", ylab="density",
groupFactor=substr(colnames(bc2),1,1))
legend("topright",legend=c("CCLE","Minna","Tumor"), col=RColorBrewer::brewer.pal(8, "Dark2")[1:3], lwd=2)
matdensity(bc2, main="Batch corrected", xlab="log2 expression", ylab="density",
groupFactor=substr(colnames(bc2),1,1))
legend("topright",legend=c("CCLE","Minna","Tumor"), col=RColorBrewer::brewer.pal(8, "Dark2")[1:3], lwd=2)
matdensity(bc2_mean.only, main="Batch corrected", xlab="log2 expression", ylab="density",
groupFactor=substr(colnames(bc2),1,1))
legend("topright",legend=c("CCLE","Minna","Tumor"), col=RColorBrewer::brewer.pal(8, "Dark2")[1:3], lwd=2)
write.csv(bc2, file = "../../data/bulk-rna-seq/CCLE_Minna_Thomas_COMBAT.csv")
View(bc2)
